<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <!-- Disabled built-in browser zoom -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Image Annotator</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      font-family: sans-serif;
    }
    #canvas {
      background: #eee;
      display: block;
      touch-action: none;
    }
    #toolbar {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: space-around;
      align-items: center;
      padding: 10px 0;
      z-index: 10;
    }
    #toolbar button {
      color: #fff;
      background: none;
      border: 1px solid #fff;
      border-radius: 5px;
      padding: 10px 15px;
      font-size: 14px;
      cursor: pointer;
    }
    #toolbar button.active {
      background-color: #007BFF;
      border-color: #007BFF;
    }
    /* JSON editor modal styling */
    #jsonModal {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #fff;
      border: 1px solid #ccc;
      padding: 20px;
      z-index: 20;
      display: none;
      width: 80%;
      max-width: 500px;
      max-height: 80%;
      overflow: auto;
    }
    #jsonModal textarea {
      width: 100%;
      height: 200px;
    }
    #jsonModal button {
      margin-top: 10px;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <input type="file" id="imageLoader" accept="image/*" hidden>
  <input type="file" id="jsonLoader" accept=".json" hidden>

  <!-- JSON editor modal -->
  <div id="jsonModal">
    <h3>Edit JSON</h3>
    <textarea id="jsonTextarea"></textarea>
    <br>
    <button id="updateJsonBtn">Update</button>
    <button id="closeJsonModal">Close</button>
  </div>

  <!-- Toolbar -->
  <div id="toolbar">
    <button id="selectImageBtn">Select Image</button>
    <button id="drawToolBtn">Draw</button>
    <button id="eraserToolBtn">Erase</button>
    <button id="undoBtn">Undo Erase</button>
    <button id="exportJsonBtn">Export JSON</button>
    <button id="loadJsonBtn">Load JSON</button>
    <button id="editJsonBtn">Edit JSON</button>
    <button id="resetBtn">Reset</button>
  </div>

  <script>
    (function() {
      // Cache elements and define state
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      const imageLoader = document.getElementById('imageLoader');
      const jsonLoader = document.getElementById('jsonLoader');
      const jsonModal = document.getElementById('jsonModal');
      const jsonTextarea = document.getElementById('jsonTextarea');

      let image = new Image();
      let imageLoaded = false;
      let imageResolution = { width: 0, height: 0 };
      let lines = []; // Each line: { start: {x, y}, end: {x, y} }
      let currentTool = 'draw'; // Modes: "draw" or "erase"
      let drawing = false;
      let currentLine = null;
      let drawStartTime = 0;
      // Stack for multiple erased lines.
      let erasedStack = [];

      // Transformation state for image/annotations.
      let transform = { scale: 1, rotation: 0, centerX: 0, centerY: 0 };
      let baseScale = 1;
      // Gesture state for multi-touch events.
      let isGesture = false;
      let gestureInitialDistance = 0;
      let gestureInitialAngle = 0;
      let gestureInitialCenter = { x: 0, y: 0 };
      // New: record the image coordinate corresponding to the initial two-finger center.
      let gestureInitialImageCoord = { x: 0, y: 0 };
      let initialTransform = { scale: 1, rotation: 0, centerX: 0, centerY: 0 };

      /* Utility Functions */

      // Resize canvas to fit window.
      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        if (imageLoaded) {
          transform.centerX = canvas.width / 2;
          transform.centerY = canvas.height / 2;
        }
        draw();
      }

      // Convert an image coordinate to canvas coordinate.
      function transformPoint(x, y) {
        const dx = x - image.width / 2;
        const dy = y - image.height / 2;
        const cos = Math.cos(transform.rotation);
        const sin = Math.sin(transform.rotation);
        const rotatedX = dx * cos - dy * sin;
        const rotatedY = dx * sin + dy * cos;
        return {
          x: transform.centerX + rotatedX * transform.scale,
          y: transform.centerY + rotatedY * transform.scale
        };
      }

      // Convert a canvas coordinate to image coordinate.
      function toImageCoords(x, y) {
        let dx = x - transform.centerX;
        let dy = y - transform.centerY;
        dx /= transform.scale;
        dy /= transform.scale;
        const cos = Math.cos(-transform.rotation);
        const sin = Math.sin(-transform.rotation);
        return {
          x: dx * cos - dy * sin + image.width / 2,
          y: dx * sin + dy * cos + image.height / 2
        };
      }

      // Calculate distance and angle between two touch points.
      function getTouchDistance(t1, t2) {
        return Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
      }
      function getTouchAngle(t1, t2) {
        return Math.atan2(t2.clientY - t1.clientY, t2.clientX - t1.clientX);
      }

      // Distance from point p to segment vw.
      function pointToSegmentDistance(p, v, w) {
        const l2 = (w.x - v.x) ** 2 + (w.y - v.y) ** 2;
        if (l2 === 0) return Math.hypot(p.x - v.x, p.y - v.y);
        let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
        t = Math.max(0, Math.min(1, t));
        const projection = { x: v.x + t * (w.x - v.x), y: v.y + t * (w.y - v.y) };
        return Math.hypot(p.x - projection.x, p.y - projection.y);
      }

      // Draw the image and annotations.
      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (imageLoaded) {
          ctx.save();
          ctx.translate(transform.centerX, transform.centerY);
          ctx.rotate(transform.rotation);
          ctx.scale(transform.scale, transform.scale);
          ctx.drawImage(image, -image.width / 2, -image.height / 2);
          ctx.restore();
        }
        ctx.lineWidth = 2;
        ctx.strokeStyle = 'red';
        lines.forEach(line => {
          const start = transformPoint(line.start.x, line.start.y);
          const end = transformPoint(line.end.x, line.end.y);
          ctx.beginPath();
          ctx.moveTo(start.x, start.y);
          ctx.lineTo(end.x, end.y);
          ctx.stroke();
        });
        // Draw preview of the current line.
        if (drawing && currentLine) {
          const start = transformPoint(currentLine.start.x, currentLine.start.y);
          const end = transformPoint(currentLine.end.x, currentLine.end.y);
          ctx.beginPath();
          ctx.moveTo(start.x, start.y);
          ctx.lineTo(end.x, end.y);
          ctx.stroke();
        }
      }

      // Update toolbar button active state.
      function updateActiveTool() {
        document.querySelectorAll('#toolbar button').forEach(btn => btn.classList.remove('active'));
        if (currentTool === 'draw') {
          document.getElementById('drawToolBtn').classList.add('active');
        } else if (currentTool === 'erase') {
          document.getElementById('eraserToolBtn').classList.add('active');
        }
      }

      /* Event Handlers */

      function handlePointerDown(e) {
        // Begin multi-touch gesture if two or more touches detected.
        if (e.touches && e.touches.length >= 2) {
          drawing = false;
          currentLine = null;
          e.preventDefault();
          isGesture = true;
          const [t1, t2] = [e.touches[0], e.touches[1]];
          gestureInitialDistance = getTouchDistance(t1, t2);
          gestureInitialAngle = getTouchAngle(t1, t2);
          // Record the center between the two touches.
          const initialCenterCanvas = {
            x: (t1.clientX + t2.clientX) / 2,
            y: (t1.clientY + t2.clientY) / 2
          };
          gestureInitialCenter = initialCenterCanvas;
          // Capture the corresponding image coordinate using the current transform.
          gestureInitialImageCoord = toImageCoords(initialCenterCanvas.x, initialCenterCanvas.y);
          initialTransform = {
            scale: transform.scale,
            rotation: transform.rotation,
            centerX: transform.centerX,
            centerY: transform.centerY
          };
          return;
        }
        if (!imageLoaded) return;
        const pos = e.touches
          ? toImageCoords(e.touches[0].clientX, e.touches[0].clientY)
          : toImageCoords(e.clientX, e.clientY);
        if (currentTool === 'draw') {
          drawing = true;
          currentLine = { start: pos, end: pos };
          drawStartTime = Date.now();
        } else if (currentTool === 'erase') {
          eraseAt(pos);
        }
      }

      function handlePointerMove(e) {
        if (e.touches && e.touches.length >= 2 && isGesture) {
          e.preventDefault();
          const [t1, t2] = [e.touches[0], e.touches[1]];
          const currentDistance = getTouchDistance(t1, t2);
          const currentAngle = getTouchAngle(t1, t2);
          const currentCenter = {
            x: (t1.clientX + t2.clientX) / 2,
            y: (t1.clientY + t2.clientY) / 2
          };
          // Compute new scale and rotation.
          const newScale = initialTransform.scale * (currentDistance / gestureInitialDistance);
          const newRotation = initialTransform.rotation + (currentAngle - gestureInitialAngle);
          transform.scale = newScale;
          transform.rotation = newRotation;
          // Adjust center so that the image coordinate under the initial gesture center remains at the current center.
          transform.centerX = currentCenter.x - newScale * (
            Math.cos(newRotation) * (gestureInitialImageCoord.x - image.width / 2) -
            Math.sin(newRotation) * (gestureInitialImageCoord.y - image.height / 2)
          );
          transform.centerY = currentCenter.y - newScale * (
            Math.sin(newRotation) * (gestureInitialImageCoord.x - image.width / 2) +
            Math.cos(newRotation) * (gestureInitialImageCoord.y - image.height / 2)
          );
          draw();
          return;
        }
        if (!imageLoaded) return;
        const pos = e.touches
          ? toImageCoords(e.touches[0].clientX, e.touches[0].clientY)
          : toImageCoords(e.clientX, e.clientY);
        if (currentTool === 'draw' && drawing && !isGesture) {
          currentLine.end = pos;
          draw();
        } else if (currentTool === 'erase' && !isGesture) {
          eraseAt(pos);
        }
      }

      function handlePointerUp(e) {
        if (e.touches && isGesture && e.touches.length < 2) {
          isGesture = false;
          return;
        }
        if (currentTool === 'draw' && drawing && !isGesture) {
          const duration = Date.now() - drawStartTime;
          if (duration >= 200) {
            // Round off coordinates before storing.
            lines.push({
              start: { x: Math.round(currentLine.start.x), y: Math.round(currentLine.start.y) },
              end: { x: Math.round(currentLine.end.x), y: Math.round(currentLine.end.y) }
            });
          }
          currentLine = null;
          drawing = false;
          draw();
        }
      }

      // Eraser: find and remove the closest line near the pointer.
      function eraseAt(pos) {
        const threshold = 5 / transform.scale;
        let closestIndex = -1;
        let closestDistance = Infinity;
        lines.forEach((line, index) => {
          const dist = pointToSegmentDistance(pos, line.start, line.end);
          if (dist <= threshold && dist < closestDistance) {
            closestDistance = dist;
            closestIndex = index;
          }
        });
        if (closestIndex !== -1) {
          // Push the erased line and its index onto the stack.
          erasedStack.push({ line: lines[closestIndex], index: closestIndex });
          lines.splice(closestIndex, 1);
          draw();
        }
      }

      /* Toolbar and File Handling */

      function setupToolbar() {
        document.getElementById('selectImageBtn').addEventListener('click', () => imageLoader.click());
        imageLoader.addEventListener('change', handleImageSelect);
        document.getElementById('drawToolBtn').addEventListener('click', () => {
          currentTool = 'draw';
          updateActiveTool();
        });
        document.getElementById('eraserToolBtn').addEventListener('click', () => {
          currentTool = 'erase';
          updateActiveTool();
        });
        // Undo restores the most recently erased line.
        document.getElementById('undoBtn').addEventListener('click', () => {
          if (erasedStack.length) {
            const lastErased = erasedStack.pop();
            lines.splice(lastErased.index, 0, lastErased.line);
            draw();
          }
        });
        document.getElementById('resetBtn').addEventListener('click', () => {
          lines = [];
          draw();
        });
        // Export JSON downloads the data as a .json file.
        document.getElementById('exportJsonBtn').addEventListener('click', () => {
          const output = { imageResolution, lines };
          const jsonStr = JSON.stringify(output, null, 2);
          const blob = new Blob([jsonStr], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = 'annotations.json';
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        });
        document.getElementById('loadJsonBtn').addEventListener('click', () => jsonLoader.click());
        jsonLoader.addEventListener('change', handleJsonLoad);
        document.getElementById('editJsonBtn').addEventListener('click', () => {
          const output = { imageResolution, lines };
          jsonTextarea.value = JSON.stringify(output, null, 2);
          jsonModal.style.display = 'block';
        });
        document.getElementById('updateJsonBtn').addEventListener('click', handleJsonUpdate);
        document.getElementById('closeJsonModal').addEventListener('click', () => {
          jsonModal.style.display = 'none';
        });
      }

      function handleImageSelect(e) {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function(event) {
          image.onload = function() {
            imageLoaded = true;
            imageResolution = { width: image.width, height: image.height };
            // Fit image within canvas.
            baseScale = Math.min(canvas.width / image.width, canvas.height / image.height);
            transform = {
              scale: baseScale,
              rotation: 0,
              centerX: canvas.width / 2,
              centerY: canvas.height / 2
            };
            draw();
          }
          image.src = event.target.result;
        }
        reader.readAsDataURL(file);
      }

      function handleJsonLoad(e) {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function(event) {
          try {
            const data = JSON.parse(event.target.result);
            if (data.lines && data.imageResolution) {
              imageResolution = data.imageResolution;
              lines = data.lines;
              draw();
            } else {
              alert('Invalid JSON format.');
            }
          } catch (err) {
            alert('Error parsing JSON.');
          }
        }
        reader.readAsText(file);
      }

      function handleJsonUpdate() {
        try {
          const data = JSON.parse(jsonTextarea.value);
          if (data.lines && data.imageResolution) {
            imageResolution = data.imageResolution;
            lines = data.lines;
            draw();
            jsonModal.style.display = 'none';
          } else {
            alert('Invalid JSON format.');
          }
        } catch (err) {
          alert('Error parsing JSON.');
        }
      }

      function setupCanvasEvents() {
        canvas.addEventListener('mousedown', handlePointerDown);
        canvas.addEventListener('mousemove', handlePointerMove);
        canvas.addEventListener('mouseup', handlePointerUp);
        canvas.addEventListener('touchstart', handlePointerDown, { passive: false });
        canvas.addEventListener('touchmove', handlePointerMove, { passive: false });
        canvas.addEventListener('touchend', handlePointerUp);
      }

      /* Initialization */
      function init() {
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        setupToolbar();
        setupCanvasEvents();
        updateActiveTool();
      }

      document.addEventListener('DOMContentLoaded', init);
    })();
  </script>
</body>
</html>
